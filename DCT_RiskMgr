using System;
using System.Linq;
using System.Collections;
using cAlgo.API;
using cAlgo.API.Indicators;
using cAlgo.API.Internals;
using cAlgo.Indicators;
using System.Collections.Generic;


namespace cAlgo.Robots
{
    [Robot(TimeZone = TimeZones.UTC, AccessRights = AccessRights.FullAccess)]
    public class DCT_Risk : Robot
    {

        [Parameter("Label ID", DefaultValue = "DCT")]
        public string LabelPrefix { get; set; }

        [Parameter("Risk Max (%)", DefaultValue = 1, Step = 0.05)]
        public double Risk_Max { get; set; }

        [Parameter("Risk Min (%)", DefaultValue = 0.25, Step = 0.05)]
        public double Risk_Min { get; set; }

        [Parameter("R-r Ratio", DefaultValue = 1, Step = 0.05)]
        public double RrRatio { get; set; }

        [Parameter("Risk Cover (%)", DefaultValue = 50, Step = 5)]
        public double Risk_Cover { get; set; }

        [Parameter("Debug Mode", DefaultValue = true)]
        public bool DebugMode { get; set; }
        public bool UseTrailingStop = false;

        int BuyOrSell, counter;
        double SL_pips;
        Symbol Asset;
        double totalValue, totalEaR;
        double BreakevenVolume;
        double BadVolumeSize = 10000;

        ArrayList Balances, PL;
        double EquityPeak, EquityTrough;
        double Profits, Losses, avgProfit, avgLoss;
        int countWin, countLoss;
        TimeSpan TotalDuration;
        long AvgDuration_Ticks;
        double Q3_PnL;
        Dictionary<string, double> dictEaR;

        protected override void OnStart()
        {
            Positions.Closed += OnPositionsClosed;
            dictEaR = new Dictionary<string, double>();
            Balances = new ArrayList();
            CalcStats();
        }

        void OnPositionsClosed(PositionClosedEventArgs obj)
        {
            UpdateTradeStats(obj.Position);
        }

        protected override void OnBar()
        {
            if (Positions.FindAll(LabelPrefix).Count() > 0)
            {
                FilterTrades(LabelPrefix);
                Print("Avg Trade Duration (1/3): {0} Hours", Math.Round(TimeSpan.FromTicks(AvgDuration_Ticks).TotalHours, 2));

                foreach (Position pos in Positions.FindAll(LabelPrefix))
                {
                    CheckSL(pos);
                    Asset = Symbols.GetSymbol(pos.SymbolName);
                    BuyOrSell = pos.TradeType == TradeType.Buy ? 1 : -1;
                    double OrigVolume = double.Parse(pos.Comment.Split('_').Last());
                    if (pos.StopLoss.HasValue)
                    {
                        //Print("=== INITIAL LOSS ===");
                        CloseHalf(pos, Asset, avgProfit, OrigVolume);
                        //Print("=== INITIAL TP ===");
                        BreakevenTrade(pos, 2, OrigVolume);
                        //Print("=== FRRE LOADER CHECK ===");
                        TimeChecks(pos, Asset, AvgDuration_Ticks, Q3_PnL);
                    }
                    EquityAtRisk(dictEaR, pos.SymbolName, pos, Asset);
                    counter++;
                }
                PrintRisk();
            }
        }

        private void CalcStats()
        {
            Profits = 0.0;
            Losses = 0.0;
            countWin = 0;
            countLoss = 0;
            EquityPeak = 0.0;
            EquityTrough = 0.0;
            double sumEq = 0.0;
            double prevBalance = 0;
            TotalDuration = new TimeSpan(0);
            foreach (HistoricalTrade h in History.FindAll(LabelPrefix))
            {
                if (h.NetProfit > 0)
                {
                    Profits += h.NetProfit;
                    countWin++;
                }
                else if (h.NetProfit < 0)
                {
                    Losses += h.NetProfit;
                    countLoss++;
                }
                TotalDuration += h.ClosingTime - h.EntryTime;
                Balances.Add(prevBalance + h.NetProfit);
                PL.Add(h.NetProfit);
            }
            AvgDuration_Ticks = (long)Math.Round((double)(TotalDuration.Ticks / (countWin + countLoss)), 0);

            EquityPeak = (double)Balances.ToArray().Max();

            Print("equity calcs");
            for (var i = 1; i < 20; i++)
                sumEq += (double)(Balances[Balances.Count - i]);

            EquityTrough = sumEq / 20;
            double pureEquityTrough = (double)Balances.ToArray().Min();
            avgProfit = Profits / countWin;
            avgLoss = Losses / countLoss;
            double GE = (countWin * avgProfit + countLoss * avgLoss) / (countWin + countLoss);
            double SD = StdDev(PL);
            Print("Eq Peak: {0} Abs: {1}", EquityPeak, pureEquityTrough);
            Print("Eq Trough: {0}", EquityTrough);
            Print("Eq prev Bal: {0}", prevBalance);
            Print("Avg Profits: {0:F2}\tLosses: {1:F2}", avgProfit, avgLoss);
            Print("Sum Profits: {0:F0}\tLosses: {1:F0}", Profits, Losses);
            Print("Counts Wins: {0}\tLosses: {1}", countWin, countLoss);
            Print("GE: {0:F2}\tPF: {1:F2}\tSD: {3:F2}", GE, Math.Abs(Profits / Losses));
        }

        private void UpdateTradeStats(Position p)
        {
            if (p.NetProfit > 0)
            {
                Profits += p.NetProfit;
                countWin++;
                avgProfit = Profits / countWin;
            }
            else if (p.NetProfit < 0)
            {
                Losses += p.NetProfit;
                countLoss++;
                avgLoss = Losses / countLoss;
            }
            AvgDuration_Ticks = AvgDuration_Ticks + (DateTime.Now.AddSeconds(5).Ticks - p.EntryTime.Ticks) / 3;
            EquityPeak = Math.Max(Account.Equity + p.NetProfit, EquityPeak);
            EquityTrough = Math.Min(Account.Equity + p.NetProfit, EquityTrough);
        }

        private void PrintRisk()
        {
            foreach (var asset in dictEaR)
            {
                totalValue += double.Parse(asset.Value.ToString());
                Print("{0}: {1:P2}", asset.Key, asset.Value);
            }
            Print("{0} Trades: {1:P2}\t{2:0.##}", counter, totalValue, totalValue * Account.Balance);

            totalValue = 0.0;
            counter = 0;
            dictEaR.Clear();
        }

        private void CheckSL(Position p)
        {
            if (!p.StopLoss.HasValue)
            {
                Print("No Stop Loss set. Setting to 2x DailyATR");
                p.ModifyStopLossPips(GetATR(Symbols.GetSymbol(p.SymbolName), TimeFrame.Daily, 2));
                return;
            }
        }

        private int TradeCounter(string Label)
        {
            var counter = Positions.FindAll(Label).Count();
            return counter;
        }
        private double GetATR(Symbol s, TimeFrame tf, double ATR_Multiple)
        {
            double atr = Indicators.AverageTrueRange(MarketData.GetBars(tf, s.Name), 20, MovingAverageType.Simple).Result.LastValue;
            return Math.Round(ATR_Multiple * atr / s.PipSize, 1);
        }

        private double GetOrderVolume(double StopLoss, double Risk, int NoOfTrades, Symbol sym)
        {
            double risk_tranche = Risk / NoOfTrades;
            double _OrderVolume = ((Account.Balance * risk_tranche / 100) / StopLoss / sym.PipValue);
            double FinalVolume = Math.Max(sym.VolumeInUnitsMin * 2, Math.Min(BadVolumeSize, _OrderVolume));
            return sym.NormalizeVolumeInUnits(FinalVolume);
        }

        private double StdDev(ArrayList values)
        {
            double standardDeviation = 0;

            double avg = values.Average();
            double sum = values.Sum(d => Math.Pow(d - avg, 2));
            standardDeviation = Math.Sqrt((sum) / (values.Count() - 1));
            return standardDeviation;
        }

        void EquityAtRisk(Dictionary<string, double> Dict, string Key, Position p, Symbol s)
        {
            totalEaR = 0.0;
            totalValue = 0.0;
            BuyOrSell = p.TradeType == TradeType.Buy ? 1 : -1;
            double EaR = BuyOrSell * ((p.StopLoss.Value - p.EntryPrice) / s.PipSize) * s.PipValue * p.VolumeInUnits;
            totalEaR += EaR;

            if (Dict.ContainsKey(Key))
            {
                Dict[Key] = Dict[Key] + EaR / Account.Balance;
            }
            else
            {
                Dict.Add(Key, EaR / Account.Balance);
            }
        }

        void BreakevenTrade(Position p, double StartTrailing, double OriginalVolume)
        {
            SL_pips = Math.Round(Math.Abs(p.EntryPrice - p.StopLoss.Value) / Asset.PipSize, 1);
            if (p.Pips > SL_pips && !p.HasTrailingStop && (p.VolumeInUnits != OriginalVolume || p.VolumeInUnits == Asset.VolumeInUnitsMin))
            {
                Print("Start Trailing Position");
                p.ModifyTrailingStop(true);
                if ((p.TradeType == TradeType.Buy && p.StopLoss < p.EntryPrice) || (p.TradeType == TradeType.Sell && p.EntryPrice < p.StopLoss))
                    p.ModifyStopLossPrice(p.EntryPrice);
            }

            BreakevenVolume = p.Pips / (p.Pips + SL_pips);
            double RiskOff = 1;
            if ((BreakevenVolume > 0.3 || p.Pips > RiskOff * SL_pips) && p.VolumeInUnits == OriginalVolume)
            {
                double NewVolume = Asset.NormalizeVolumeInUnits(p.VolumeInUnits * BreakevenVolume, RoundingMode.Down);
                Print("{0}: {1} ==> {2}\tR-r Ratio: {3:P2}", p.SymbolName, p.VolumeInUnits, NewVolume, BreakevenVolume);
                p.ModifyVolume(NewVolume);
                p.ModifyTrailingStop(true);
            }
        }

        private void CloseHalf(Position p, Symbol s, double avgProfit, double OriginalVolume)
        {
            if (p.NetProfit < -2 * avgProfit && p.VolumeInUnits == OriginalVolume)
            {
                Print("Trade MTM is -0.5R, closing half: {0}=={1}", p.Label, p.Comment);
                p.ModifyVolume(s.NormalizeVolumeInUnits(p.VolumeInUnits * 0.5, RoundingMode.Down));
            }
        }

        private void TimeChecks(Position p, Symbol s, long AvgDuration, double PnL)
        {
            //Print("{0}\t{1}\t{2}", p.Id, p.EntryTime.AddTicks(AvgDuration).ToUniversalTime(), DateTime.Now.ToUniversalTime());

            if (p.NetProfit > PnL)
                if (p.EntryTime.AddTicks(AvgDuration).ToUniversalTime() < DateTime.Now.ToUniversalTime())
                {
                    double OrigVolume = double.Parse(p.Comment.Split('_').Last());
                    if (p.VolumeInUnits == s.VolumeInUnitsMin)
                    {
                        p.Close();
                    }
                    else if ((p.VolumeInUnits == OrigVolume) || (p.VolumeInUnits == s.NormalizeVolumeInUnits(p.VolumeInUnits * 0.5)))
                    {
                        p.ModifyVolume(s.NormalizeVolumeInUnits(p.VolumeInUnits * 2 / 3, RoundingMode.Down));
                    }
                }
        }

        private void FilterTrades(string Label)
        {
            Dictionary<int, double> Pid = new Dictionary<int, double>();
            foreach (Position p in Positions.FindAll(Label))
                Pid.Add(p.Id, p.NetProfit);

            List<double> PnL = Pid.Values.ToList();
            PnL.Sort();
            PnL.Reverse();
            double Median = Find_Median(PnL);
            List<double> Median_list = PnL.Where(x => x > Median).ToList();
            double Q3 = Find_Median(Median_list);
            List<double> Q3_list = Median_list.Where(x => x > Q3).ToList();
            Print("Median: {0}, Q3: {1}", Median, Q3);
            Q3_PnL = Q3;
            //for (var i = 0; i < Q3_list.Count; i++)
            //  Print(Q3_list[i]);
        }

        public static double Find_Median(List<double> list)
        {
            double Size = list.Count;
            double Final_Number = 0;
            if (Size % 2 == 0)
            {
                int HalfWay = list.Count / 2;
                double Value1 = Convert.ToDouble(list[HalfWay - 1].ToString());
                double Value2 = Convert.ToDouble(list[HalfWay - 1 + 1].ToString());
                double Number = Value1 + Value2;
                Final_Number = Number / 2;
            }
            else
            {
                int HalfWay = list.Count / 2;
                double Value1 = Convert.ToDouble(list[HalfWay].ToString());
                Final_Number = Value1;
            }
            return (double)(Final_Number);
        }

        private double WinRate()
        {
            return countWin / (countWin + countLoss);
        }

    }
}
